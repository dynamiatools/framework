/*
 * Copyright (C) 2023 Dynamia Soluciones IT S.A.S - NIT 900302344-1
 * Colombia / South America
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.dynamia.integration.ms;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.event.EventListener;
import tools.dynamia.commons.StringUtils;

import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * Spring-based implementation of {@link MessageService} using Spring Application Events.
 * This implementation leverages Spring's event publishing mechanism to provide messaging
 * capabilities within a Spring application context.
 * <p>
 * Messages are published as Spring ApplicationEvents, and listeners are registered
 * dynamically. This allows for loose coupling between message producers and consumers
 * within the same application.
 * </p>
 * <p>
 * Channels are logical groupings for messages, and topics provide additional filtering
 * within channels. Broadcasting sends messages to all channels.
 * </p>
 *
 * @author Generated by AI Assistant
 */

public class SpringApplicationEventsMessageService implements MessageService {

    public static final String CHANNEL = "channel";
    public static final String TOPIC = "topic";
    public static final String CALLBACK = "callback";
    private final ApplicationEventPublisher eventPublisher;
    private final Map<String, MessageChannel> channels = new ConcurrentHashMap<>();
    private final Map<String, Map<String, List<MessageListener<?>>>> listeners = new ConcurrentHashMap<>();

    @Autowired
    public SpringApplicationEventsMessageService(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }

    @Override
    public MessageChannel createChannel(String name) {
        return channels.computeIfAbsent(name, n -> new SpringMessageChannel(n, this));
    }

    @Override
    public MessageChannel createChannel(String name, Properties properties) {
        // For Spring events, properties are ignored as configuration is handled by Spring
        return createChannel(name);
    }

    @Override
    public Optional<MessageChannel> getChannel(String name) {
        return Optional.ofNullable(channels.get(name));
    }

    @Override
    public void publish(String channelName, Message message) {
        publish(channelName, message, null, null);
    }

    @Override
    public void publish(String channelName, Message message, String topic) {
        publish(channelName, message, topic, null);
    }

    @Override
    public void publish(String channelName, Message message, String topic, String callback) {
        message.addHeader(CHANNEL, channelName);
        message.addHeader(TOPIC, topic);
        message.addHeader(CALLBACK, callback);
        eventPublisher.publishEvent(message);
    }

    @Override
    public void broadcast(Message message) {
        broadcast(message, null, null);
    }

    @Override
    public void broadcast(Message message, String topic) {
        broadcast(message, topic, null);
    }

    @Override
    public void broadcast(Message message, String topic, String callback) {
        // Broadcast to all channels
        channels.keySet().forEach(channelName -> publish(channelName, message, topic, callback));
    }

    @Override
    public <T extends Message> MessageChannelSubscription subscribe(String channelName, MessageListener<T> listener) {
        return subscribe(channelName, null, listener);
    }

    @Override
    public <T extends Message> MessageChannelSubscription subscribe(String channelName, String topic, MessageListener<T> listener) {
        listeners.computeIfAbsent(channelName, k -> new ConcurrentHashMap<>())
                .computeIfAbsent(topic, k -> new CopyOnWriteArrayList<>())
                .add(listener);

        return new SpringMessageChannelSubscription(channelName, topic, listener, this);
    }

    @EventListener
    public void onMessage(Message message) {
        String channel = (String) message.getHeader(CHANNEL);
        String topic = (String) message.getHeader(TOPIC);
        String callback = (String) message.getHeader(CALLBACK);

        if (channel != null) {
            Map<String, List<MessageListener<?>>> channelListeners = listeners.get(channel);
            if (channelListeners != null) {
                // Notify listeners for the specific topic
                List<MessageListener<?>> topicListeners = channelListeners.get(topic);
                if (topicListeners != null) {
                    MessageEvent<Message> event = new MessageEvent<>(message, topic, callback);
                    topicListeners.forEach(listener -> {
                        try {
                            ((MessageListener<Message>) listener).onMessage(event);
                        } catch (ClassCastException e) {
                            // Ignore if type doesn't match
                        }
                    });
                }

                // Also notify listeners subscribed to all topics (null topic)
                List<MessageListener<?>> allTopicListeners = channelListeners.get(null);
                if (allTopicListeners != null) {
                    MessageEvent<Message> event = new MessageEvent<>(message, topic, callback);
                    allTopicListeners.forEach(listener -> {
                        try {
                            ((MessageListener<Message>) listener).onMessage(event);
                        } catch (ClassCastException e) {
                            // Ignore if type doesn't match
                        }
                    });
                }
            }

            // Also notify global listeners using MessageChannels.lookupListeners
            List<MessageListener> globalListeners = MessageChannels.lookupListeners(channel, topic != null ? topic : "");
            for (MessageListener listener : globalListeners) {
                try {
                    MessageEvent<Message> event = new MessageEvent<>(message, channel, topic);
                    ((MessageListener<Message>) listener).onMessage(event);
                } catch (ClassCastException e) {
                    // Ignore if type doesn't match
                }
            }
        }
    }

    void unsubscribe(String channelName, String topic, MessageListener<?> listener) {
        Map<String, List<MessageListener<?>>> channelListeners = listeners.get(channelName);
        if (channelListeners != null) {
            List<MessageListener<?>> topicListeners = channelListeners.get(topic);
            if (topicListeners != null) {
                topicListeners.remove(listener);
                if (topicListeners.isEmpty()) {
                    channelListeners.remove(topic);
                }
            }
            if (channelListeners.isEmpty()) {
                listeners.remove(channelName);
            }
        }
    }

    /**
     * Simple implementation of MessageChannel for Spring events.
     */
    private static class SpringMessageChannel implements MessageChannel {
        private final String name;
        private final SpringApplicationEventsMessageService service;

        public SpringMessageChannel(String name, SpringApplicationEventsMessageService service) {
            this.name = name;
            this.service = service;
        }

        @Override
        public String getName() {
            return name;
        }

        @Override
        public void publish(Message message) {
            service.publish(name, message);
        }

        @Override
        public void publish(Message message, String topic) {
            service.publish(name, message, topic);
        }

        @Override
        public void publish(Message message, String topic, String callback) {
            service.publish(name, message, topic, callback);
        }

        @Override
        public <T extends Message> MessageChannelSubscription subscribe(MessageListener<T> listener) {
            return service.subscribe(name, listener);
        }

        @Override
        public <T extends Message> MessageChannelSubscription subscribe(String topic, MessageListener<T> listener) {
            return service.subscribe(name, topic, listener);
        }
    }

    /**
     * Simple implementation of MessageChannelSubscription for Spring events.
     */
    private static class SpringMessageChannelSubscription extends BaseMessageChannelSubscription {

        private final SpringApplicationEventsMessageService service;

        public SpringMessageChannelSubscription(String channelName, String topic, MessageListener<?> listener, SpringApplicationEventsMessageService service) {
            super(channelName, topic, StringUtils.randomString(), listener);
            this.service = service;
        }

        @Override
        public void unsubscribe() {
            service.unsubscribe(getChannelName(), getTopic(), getListener());
        }

        @Override
        public boolean isActive() {
            // For simplicity, assume always active until unsubscribed
            return true;
        }
    }
}
